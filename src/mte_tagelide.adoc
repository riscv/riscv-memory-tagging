[[TAGCHECK_ELIDE]]
== tag check elide extension

`Zitagelide` is defined to aid software to elide tag checks on memory accesses
on a tagged page, and is dependent on `Zimt`, `C` and `Zcmop` extensions.

Certain regular load or store can be elided for tag checks if software
(compiler) can statically determine that they are safe to access. One such
situation is function locals where compiler can statically determine that
memory access is not out of bounds or out of scope. Although pointers to
function locals passed to another function will require tag checks. Thus page
tables will mark such pages as tagged data page. To help software elide tag
checks on tagged pages, `Zitagelide` introduces a new hart state `transient tag
check disable` (TTCD) state and is defined as below:

* 0 - `TAG_CHECK_ENFORCED` - If memory tagging is enabled, tag checks enforced.
* 1 - `TAG_CHECK_ELIDE` - If memory tagging is enabled, tag checks elided.

`Zitagelide` defines a new instruction `nietc` short for next instruction elide
tag check(s). Encoding for `nietc` is taken from `C.MOP.3`, thus making `Zimt`
dependent on `C` and `Zcmop` extensions. If memory tagging is enabled, then
instruction `nietc` sets `TTCD` to `TAG_CHECK_ELIDE` state. A subsequent
regular memory load or store clears `TTCD` to `TAG_CHECK_ENFORCED`. Thus any
regular load or store originating from subsequent instruction can be elided
for tag checks and re-arms the hart to check for tags thereafter.

[NOTE]
Compiler can insert `nietc` before loads and stores which are accessing
objects local to a function or container objects and gain performance back.
It will lead to a code size growth (2 additional byte per load/store) but
stack tagging will anyways lead to code size growth and it is expected that
user enabling stack tagging has opted into code size growth as a trade-off.

[[ELIDETAG_CSR_CTRL]]
=== CSR bits for elide tag check

`Zitagelide` doesn't require any enabling bit. If memory tagging is enabled in
the execution environment and an implementation implements `Zitagelide`, then
software can leverage tag `nietc` instruction. If a trap occurs between `nietc`
and subsequent instruction then `TTCD` state is spilled into *status register
of the mode where trap is being delivered. Bit position of `TTCD` spilled state
in *status register is defined as below.

==== Machine Status Register (`mstatus`)

.Machine-mode status register (`mstatus`) for RV64
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'MPIE'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'MPP[1:0]'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'MPRV'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'TVM'},
  {bits:  1, name: 'TW'},
  {bits:  1, name: 'TSR'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SPTTCD'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits:  2, name: 'SXL[1:0]'},
  {bits:  1, name: 'SBE'},
  {bits:  1, name: 'MBE'},
  {bits:  1, name: 'GVA'},
  {bits:  1, name: 'MPV'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MPELP'},
  {bits:  1, name: 'MPTTCD'},
  {bits: 20, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

The Zimt extension introduces the `SPTTCD` (bit 24) and `MPTTCD` (bit 42)
fields that hold the previous `TTCD`. The `__x__PTTCD` fields are encoded as
follows:

* 0 - `TAG_CHECK_ENFORCED` - If memory tagging is enabled, tag checks enforced.
* 1 - `TAG_CHECK_ELIDE` - If memory tagging is enabled, tag checks elided.

On a mret/sret, MPTTCD/SPTTCD is restored into hart's `TTCD` and MPTTCD/SPTTCD
is cleared.

==== Supervisor Status Register (`sstatus`)

.Supervisor-mode status register (`sstatus`) when `SXLEN=64`
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SPTTCD'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 29, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

Access to the `SPTTCD` field introduced by Zimt accesses the homonymous
fields of `mstatus` when `V=0` and the homonymous fields of `vsstatus`
when `V=1`.

On a sret, SPTTCD is restored into hart's `TTCD` and SPTTCD is cleared.

==== Virtual Supervisor Status Register (`vsstatus`)

.Virtual supervisor status register (`vsstatus`) when `VSXLEN=64`
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SPTTCD'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 29, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

The Zimt extension introduces the `SPTTCD` (bit 24) field that hold the
previous `TTCD`. The SPTTCD fields is encoded as follows:

* 0 - `TAG_CHECK_ENFORCED` - If memory tagging is enabled, tag checks enforced.
* 1 - `TAG_CHECK_ELIDE` - If memory tagging is enabled, tag checks elided.
